# This section describes the design so that the extraction tools can load it.
[src.piccolo]

# This design is written in BSV.  SystemVerilog designs are also supported,
# using `type = "verilog"`.  Chisel support is not yet implemented.
type = "bsv"

# A list of the source files that make up the design.
src-files = [ "../Piccolo/src_Core/*/*.bsv" ]

# A file containing a pre-parsed representation of the source code of the
# design.  The tool for parsing BSV source code is not available yet, so this
# option is currently mandatory.  Once the parser is available, the extraction
# tools will be able to run it on the `src-files` to produce the `ast-file`
# automatically.
ast-file = "tutorial/piccolo.cbor.gz"

# "Library packages" are packages used by the design that are not part of the
# design itself.  The extraction tools will not attempt to analyze modules from
# library packages.  Here, we mark the packages that make up the BSV standard
# library as library packages.
library-packages = [
    # BSV Prelude
    "ActionSeq", "Array", "Assert", "Clocks", "ConfigReg", "Connectable",
    "Counter", "Enum", "Environment", "FIFO", "FIFOF", "FIFOF_", "FIFOLevel",
    "FShow", "FoldFIFO", "FoldFIFOF", "Fork", "GetPut", "Inout", "LevelFIFO",
    "List", "ListN", "Once", "Prelude", "PreludeBSV", "Probe", "ProbeWire",
    "RWire", "Real", "RegFile", "Reserved", "RevertingVirtualReg", "Vector",

    # BSV Libraries
    "BGetPut", "BitonicSort", "Boolify", "BRAM_Compat", "BRAMCore", "CGetPut",
    "ClientServer", "CompletionBuffer", "DPSRAM", "DReg", "EqFunction",
    "Esl_defs", "FlexBitArith", "IVec", "LFSR", "ListFIFO", "ListReg", "Mcp",
    "ModuleAugmented", "OInt", "OVLAssertions", "PopCount", "Pull", "Push",
    "RAM", "RegTwo", "RPush", "SplitTRAM", "SPSRAM", "SRAM", "SRAMFile",
    "StmtFSM", "STRAM", "SVA", "SyncSRAM", "Tabulate", "ToString", "TRAM",
    "TriState", "TurboFIFO", "UIntRange", "UniqueWrappers", "Wallace", "ZBus",
    "ZBusUtil",

    # `Near_Mem_Caches` is part of Piccolo, but architecture extraction
    # currently enters an infinite loop when trying to process it.
    # TODO: Remove this
    "Near_Mem_Caches",
]

# Currently, only a single `src` section is supported.  In the future, the
# extraction tools will support multiple `src` sections to enable analysis of
# mixed-language designs.



# The options in this section control the graphviz output produced by the
# `besspin-arch-extract ... visualize` subcommand.
[graphviz]
# The generated graphviz files (`*.dot`) will be placed in this directory.
# besspin-arch-extract will generate one graphviz file for each module in the
# design.
out-dir = "piccolo-arch"

# The remaining options enable or disable rendering of specific kinds of
# elements.  The settings in this file cause besspin-arch-extract to display
# the architecture of each module in terms of the module instantiations it
# contains and the flow of data between their ports.
#
# For a higher-level view, hide the individual ports: set `draw-ext-ports` and
# `draw-logic-ports` to `false`.  (Or see `piccolo-high-level.toml`.)
#
# For a lower-level view, show the nets and combinational logic elements: set
# `draw-nets` and `draw-logics` to `true`.  (Or see `piccolo-low-level.toml`.)

# Draw nodes for nets?  Each net node will have an incoming edge from each
# output that drives the net, and an outgoing edge to each input connected to
# the net.  When net nodes are disabled, the inputs and outputs are connected
# to each other directly.
draw-nets = false

# Draw nodes for combinational logic?  When disabled, the input and output nets
# of each logic node will be drawn as a single net.
draw-logics = false

# Draw separate nodes for each external port?  When rendering a module with
# this setting disabled, all of the module's input ports will be drawn as a
# single input node, and similarly for its output ports.
draw-ext-ports = true

# Draw individual ports on module instantiations?  When disabled, only
# high-level dataflow between components will be visible, rather than dataflow
# to/from individual input/output ports of the module.
draw-logic-ports = true

# Deduplicate edges with the same source and target?  For example, with this
# setting disabled, `a & a` will produce two parallel edges from the `a` net to
# the combinational logic for the `&`; with this setting enabled, those two
# edges will be drawn as one.  This setting is especially useful when draw-nets
# and draw-logics are disabled, as otherwise that configuration will produce
# dozens of parallel edges, one for each distinct path from an output to an
# input.
dedup-edges = true

# Display `net1 (+2 more)` instead of `net1, net2, net3` when several nets are
# merged together.
shorten-net-names = true



# This section controls the feature model synthesis tool.
[featuresynth]

# The synthesizer requires two helper programs.  The first is a script to list
# all possible features of the current design.  This command is executed via
# `/bin/sh`, and should print a list of features to standard out (one per
# line).  The `%c` placeholder is expanded to the path to this config file.
# This lets us use the generic `list-pp-features` subcommand of
# `besspin-arch-extract`, which lists preprocessor flags that appear in
# `ifdef`s in the source files, instead of calling a custom script.  See
# `arch-extract/featuresynth/config.rkt` for other placeholders.
list-features-command = "besspin-arch-extract %c list-pp-flags"

# The second helper program is the "oracle", which determines whether a given
# configuration is valid.  It should read a configuration from standard input,
# where each line of the input is either "0" or "1", a space, and a feature
# name, and it should return zero (success) or non-zero (failure) to indicate
# whether the configuration is valid.
oracle-command = "tutorial/piccolo-featuresynth/check-config.sh %i"

# A file containing a set of initial configurations to test at startup.  This
# should usually contain a few known-valid configurations, since otherwise the
# synthesizer will need to test configurations at random to find a valid one,
# which can take a very long time.
init-tests-file = "tutorial/piccolo-featuresynth/init-tests.rktd"

# The maximum number of or/xor/mux groups and the maximum number of explicit
# dependencies to include in the generated model.  Increasing these limits will
# increase the time required to synthesize a feature model, but setting them
# too low can make it impossible to find a solution.
max-groups = 5
max-dependencies = 4

# Where to write the generated clafer model, once synthesis succeeds.
out-file = "piccolo.cfr"

# Additional explicit constraints to add to the feature model.  The synthesis
# tool will only test configurations that satisfy these constraints.  Currently
# we need a lot of these because the synthesizer cannot handle the full
# complexity of the configurations supported by Piccolo.  With future
# improvements to the synthesizer, we will be able to remove some of these and
# let the synthesizer infer them on its own.
hard-constraints = [
    "RV32",
    "(! RV64)",
    "(! RV128)",

    "(=> (|| MULT_SERIAL MULT_SYNTH) ISA_M)",

    "(! CSR_REGFILE_MIN)",
    "FABRIC64",
    "(! (|| ISA_F ISA_D ISA_FD ISA_FD_DIV ISA_F_OR_D) )",
    "(! (|| EXTERNAL_DEBUG_MODULE INCLUDE_GDB_CONTROL INCLUDE_TANDEM_VERIF) )",
    "(! (|| Sv32 SV34 SV39))",
]

